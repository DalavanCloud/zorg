# -*- python -*-

"""
Nightly Test UI instance for actual nightly test data.
"""

# FIXME: The NTStyleBrowser abstraction is no longer useful. We should kill it.

import sys
import time

import quixote
from quixote.directory import Directory
from quixote.errors import TraversalError

from lnt.db import perfdbsummary

import Util, NTStyleBrowser
from Util import safediv
from NTUtil import *

from PerfDB import Machine, Run, Test

def median(l):
    l = list(l)
    l.sort()
    N = len(l)
    return (l[(N-1)//2] + l[N//2])*.5

def median_absolute_deviation(l, med = None):
    if med is None:
        med = median(l)
    return median([abs(x - med) for x in l])

class SimpleRunUI(Directory):
    _q_exports = ["", "graph"]

    def __init__(self, root, tag, idstr):
        self.root = root
        self.tag = tag
        try:
            self.id = int(idstr)
        except ValueError, exc:
            raise TraversalError(str(exc))
        self.popupDepth = 0

    def renderPopupBegin [html] (self, id, title, hidden):
        self.popupDepth += 1
        """\
        <p>
        <a href="javascript://" onclick="toggleLayer('%s')"; id="%s_">(%s) %s</a>
        <div id="%s" style="display: %s;" class="hideable_%d">
        """ % (id, id, ("+","-")[hidden], title, id, ("","none")[hidden],
               self.popupDepth)

    def renderPopupEnd [html] (self):
        """
        </div>"""
        self.popupDepth -= 1

    def getInfo(self, db):
        request = quixote.get_request()

        compareToID = request.form.get('compare', '')
        compareTo = None
        if compareToID:
            try:
                compareTo = db.getRun(int(compareToID))
            except:
                pass

        run = db.getRun(self.id)

        # Find previous runs, ordered by time.
        runs = db.runs(run.machine).order_by(Run.start_time.desc()).all()
        # FIXME: Fold this into query.
        runs = [r for r in runs
                if 'tag' in r.info and r.info['tag'].value == self.tag]

        # Order by run_order info key, if given.
        for r in runs:
            if 'run_order' in r.info:
                has_order = True
                break
        else:
            has_order = False
        if has_order:
            runs.sort(key = lambda r: ('run_order' in r.info and
                                       r.info['run_order'].value))
            runs.reverse()

        # Find previous run to compare to.
        if compareTo is None:
            run_index = runs.index(run)
            if run_index < len(runs) - 1:
                compareTo = runs[run_index + 1]

        return run, runs, has_order, compareTo

    def show_run_page [html] (self, db, run, runs, compareTo, contents_fn):
        machine = run.machine

        """
        <center>
          <table>
            <tr>
              <td align=right>Machine:</td>
              <td>%s:%d</td>
            </tr>
            <tr>
              <td align=right>Run:</td>
              <td>%s</td>
            </tr>
        """ % (machine.name, machine.number, run.start_time)
        if compareTo:
            """
            <tr>
              <td align=right>Compare To:</td>
              <td>%s</td>
            </tr>
            """ % (compareTo.start_time,)
        """
          </table>
        </center>
        <p>
        """

        """
        <table width="100%%" border=1>
          <tr>
            <td valign="top" width="200">
              <a href="..">Homepage</a>
              <h4>Machine:</h4>
              <a href="../machines/%d/">%s:%d</a>
              <h4>Runs:</h4>
              <ul>
        """ % (machine.id, machine.name, machine.number)

        # Show a small number of neighboring runs.
        runIndex = runs.index(run)
        for r in runs[max(0,runIndex-3):runIndex+6]:
            if r == run:
                """ <li> <h3><a href="../%d/">%s</a></h3> """ % (r.id,
                                                                 r.start_time)
            else:
                """ <li> <a href="../%d/">%s</a> """ % (r.id, r.start_time)
        """
              </ul>
            </td>
            <td valign="top">
              <table border=1>
              <tr>
                <td> <b>Nickname</b> </td>
                <td> %s </td>
              </tr>
              <tr>
                <td> <b>Machine ID</b> </td>
                <td> %d </td>
              </tr>
              </table>""" %  (machine.name, machine.id)

        self.renderPopupBegin('machine_info', 'Machine Info', True)
        """
              <table border=1>"""
        info = machine.info.values()
        info.sort(key = lambda i: i.key)
        for mi in info:
            """
              <tr>
                <td> <b>%s</b> </td>
                <td>%s</td>
              </tr>
            """ % (mi.key, mi.value)
        """
              </table>"""
        self.renderPopupEnd()

        self.renderPopupBegin('run_info', 'Run Info', True)
        """
              <table border=1>"""
        info = run.info.values()
        info.sort(key = lambda i: i.key)
        for ri in info:
            """
              <tr>
                <td> <b>%s</b> </td>
                <td>%s</td>
              </tr>
            """ % (ri.key, ri.value)
        """
              </table>"""
        self.renderPopupEnd()

        contents_fn(db, run, runs, compareTo)

        """
            </td>
          </tr>
        </table>
        """

        self.root.getFooter()

    def _q_index [html] (self):
        # Get a DB connection.
        db = self.root.getDB()

        run,runs,has_order,compareTo = self.getInfo(db)
        machine = run.machine

        self.root.getHeader('Run Results', "../../..",
                            components=((self.tag,
                                         '%s/%s' % ('simple',self.tag)),
                                        ('machine',
                                         'simple/%s/machines/%d'%(self.tag,
                                                                  machine.id))),
                            addPopupJS=True, addFormCSS=True)

        self.show_run_page(db, run, runs, compareTo, self._q_index_body)

    def graph [html] (self):
        request = quixote.get_request()

        # Get a DB connection.
        db = self.root.getDB()

        run,runs,has_order,compareTo = self.getInfo(db)
        machine = run.machine

        # Load the test suite summary.
        ts_summary = perfdbsummary.get_simple_suite_summary(db, self.tag)

        # Load the form data.
        graph_tests = []
        graph_psets = []
        for name,value in request.form.items():
            if name.startswith(str('test.')):
                graph_tests.append(name[5:])
            elif name.startswith(str('pset.')):
                graph_psets.append(ts_summary.parameter_sets[int(name[5:])])

        # Get the test ids we want data for.
        test_ids = [ts_summary.test_map[(name,pset)].id
                     for name in graph_tests
                     for pset in graph_psets]

        # Load all the samples for those tests and this machine.
        q = db.session.query(Sample.run_id,Sample.test_id,
                             Sample.value).join(Run)
        q = q.filter(Run.machine_id == machine.id)
        q = q.filter(Sample.test_id.in_(test_ids))
        samples = list(q)

        # Aggregate by test id and then run key.
        #
        # FIXME: Pretty expensive.
        run_id_map = dict([(r.id,r) for r in runs])
        samples_by_test_id = {}
        for run_id,test_id,value in samples:
            d = samples_by_test_id.get(test_id)
            if d is None:
                d = samples_by_test_id[test_id] = Util.multidict()
            r = run_id_map.get(run_id)
            if r is None:
                continue

            if has_order:
                # FIXME: What to do on failure?
                run_key = int(r.info.get('run_order').value)
            else:
                run_key = time.mktime(r.start_time.timetuple())
            d[run_key] = value

        # Build the graph data
        pset_id_map = dict([(pset,i)
                            for i,pset in enumerate(ts_summary.parameter_sets)])
        legend = []
        plot_points = []
        plots = ""
        num_plots = len(graph_tests) * len(graph_psets)
        num_points = 0
        index = 0
        show_mad_error = has_order
        show_points = has_order
        show_all_points = False
        for name in graph_tests:
            for pset in graph_psets:
                test_id = ts_summary.test_map[(name,pset)].id

                # Get the plot for this test.
                #
                # FIXME: Support order by something other than time.
                errorbar_data = []
                points_data = []
                data = []
                points = []
                for x,values in samples_by_test_id.get(test_id,{}).items():
                    min_value = min(values)
                    data.append((x, min_value))
                    if show_points:
                        if show_all_points:
                            for v in values:
                                points_data.append((x, v))
                        else:
                            points_data.append((x, min_value))
                    if show_mad_error:
                        med = median(values)
                        mad = median_absolute_deviation(values, med)
                        errorbar_data.append((x, med - mad, med + mad))
                        points.append((x, min_value, mad, med))
                data.sort()
                num_points += len(data)

                col = list(Util.makeDarkColor(float(index) / num_plots))
                pts = ','.join(['[%.4f,%.4f]' % (t,v)
                                for t,v in data])
                style = "new Graph2D_LinePlotStyle(1, %r)" % col
                plots += "    graph.addPlot([%s], %s);\n" % (pts,style)

                if points_data:
                    pts_col = (0,0,0)
                    pts = ','.join(['[%.4f,%.4f]' % (t,v)
                                    for t,v in points_data])
                    style = "new Graph2D_PointPlotStyle(1, %r)" % (pts_col,)
                    plots += "    graph.addPlot([%s], %s);\n" % (pts,style)

                if errorbar_data:
                    bar_col = [c*.7 for c in col]
                    pts = ','.join(['[%.4f,%.4f,%.4f]' % (x,y_min,y_max)
                                    for x,y_min,y_max in errorbar_data])
                    style = "new Graph2D_ErrorBarPlotStyle(1, %r)" % (bar_col,)
                    plots += "    graph.addPlot([%s], %s);\n" % (pts,style)

                legend.append(("%s : P%d" % (name, pset_id_map[pset]), col))
                points.sort()
                plot_points.append(points)
                index += 1

        def graph_body [html] (db, run, runs, compare_to):
            """
            <h3>Graph</h3>
            <table>
            <tr>
            <td rowspan=2 valign="top">
              <canvas id="graph" width="600" height="400"></canvas>
            </td>
            <td valign="top">
            <table cellspacing=4 border=1>
            <tr><th colspan=2>Test</th></tr>
            """
            for name,col in legend:
                """
                <tr><td bgcolor="%02x%02x%02x">&nbsp;</td>
                <td>%s</td></tr>""" % (255*col[0], 255*col[1], 255*col[2], name)
            """
            </table>
            </td></tr>
            <tr><td align="right" valign="bottom">
            <font size="-2">
            Shift-Left Mouse: Pan<br>
            Alt/Meta-Left Mouse: Zoom<br>
            Wheel: Zoom (<i>Shift Slows</i>)<br>
            </font>
            </td></tr>
            </table>
            <p>
            <b>Plots</b>: %d<br>
            <b>Num Points<b>: %d<br>
            """ % (num_plots, num_points)

            """
            <h2>Deltas</h2>"""

            resample_list = set()
            new_sample_list = []
            for (name,col),points in zip(legend,plot_points):
                """
            <h3>%s</h3>""" % name
                """
            <table>
            <tr>
              <th colspan=2>Revision</th>
              <th> </th>
              <th colspan=2>Value</th>
              <th></th>
              <th></th>
              <th colspan=2>MAD</th>
              <th colspan=2>Med - Min</th>
            <tr>
              <th>Current</th>
              <th>Previous</th>
              <th>Delta (%)</th>
              <th>Current</th>
              <th>Previous</th>
              <th># Revs</th>
              <th> </th>
              <th>Current</th>
              <th>Previous</th>
              <th>Current</th>
              <th>Previous</th>
            </tr>"""
                points.sort()
                deltas = [(Util.safediv(p1[1], p0[1]), p0, p1)
                          for p0,p1 in Util.pairs(points)]
                deltas.sort()
                deltas.reverse()
                for (pct,(r0,t0,mad0,med0),(r1,t1,mad1,med1)) in deltas[:50]:
                    """
            <tr>
              <td><a href="http://llvm.org/viewvc/llvm-project?view=rev&revision=%d">%d</a></td>
              <td><a href="http://llvm.org/viewvc/llvm-project?view=rev&revision=%d">%d</a></td>
              %s
              <td>%.4f</td><td>%.4f</td>
              <td>%d</td>
              <td> </td>
              <td>%.4f</td><td>%.4f</td>
              <td>%.4f</td><td>%.4f</td>
            </tr>
                """ % (r1, r1, r0, r0, Util.PctCell(pct, delta=True).render(),
                       t1, t0, r1 - r0, mad1, mad0, med1-t1, med0-t0)

                    # Find the best next revision to sample, unless we have
                    # sampled to the limit. To conserve resources, we try to
                    # align to the largest "nice" revision boundary that we can,
                    # so that we tend to sample the same revisions, even as we
                    # drill down.
                    assert r0 < r1 and r0 != r1
                    if r0 + 1 != r1:
                        for align in [scale * boundary
                                      for scale in (100000,10000,1000,100,10,1)
                                      for boundary in (5, 1)]:
                            r = r0 + 1 + (r1 - r0)//2
                            r = (r // align) * align
                            if r0 < r < r1:
                                new_sample_list.append(r)
                                break

                    resample_list.add(r0)
                    resample_list.add(r1)
            """
            </table>"""

            """
            <h3>Revisions to Sample</h3>
            %s
            <p>
            <h3>Revisions to Resample</h3>
            %s
            <p>""" % (' '.join(map(str, new_sample_list)),
                      ' '.join(map(str, Util.sorted(resample_list))))

        if has_order:
            xAxis_format = 'graph.xAxis.formats.normal'
        else:
            xAxis_format = 'graph.xAxis.formats.day'
        graph_init = """\
    function init() {
        graph = new Graph2D("graph");
        graph.clearColor = [1, 1, 1];
    %s
        graph.xAxis.format = %s;
        graph.draw();
    }
    """ % (plots,xAxis_format)
        self.root.getHeader('Run Results', "../../..",
                            components=((self.tag,
                                         '%s/%s' % ('simple',self.tag)),
                                        ('machine',
                                         'simple/%s/machines/%d' %(self.tag,
                                                                   machine.id)),
                                        ('run', 'simple/%s/%d' % (self.tag,
                                                                  run.id))),
                            addPopupJS=True, addGraphJS=True,
                            addJSScript=graph_init,
                            onload="init()")

        self.show_run_page(db, run, runs, compareTo, graph_body)

    def _q_index_body [html] (self, db, run, runs, compare_to):
        # Find the tests. The simple UI maps all tests that start with
        # 'simple.'.
        #
        # One sensible addition would be to allow 'simple.foo.success' as a test
        # to indicate the success or failure of the test. We would assume that
        # the test succeeded if its .success test was missing, which leads to a
        # nice compact format (failures are expected to be rare).

        if compare_to:
            prev_id = compare_to.id
            interesting_runs = (run.id, prev_id)
        else:
            prev_id = None
            interesting_runs = (run.id,)

        # Load the test suite summary.
        ts_summary = perfdbsummary.get_simple_suite_summary(db, self.tag)

        # Load the run sample data.
        q = db.session.query(Sample.value, Sample.run_id, Sample.test_id)
        q = q.filter(Sample.run_id.in_(interesting_runs))

        sample_map = Util.multidict()
        for value,run_id,test_id in q:
            key = (run_id,test_id)
            sample_map[key] = value

        # Render the page.

        def get_cell_value [html] (test, name, pset):
            run_values = sample_map.get((run.id,test.id))
            prev_values = sample_map.get((prev_id,test.id))

            # FIXME: Check success
            failed = not run_values

            run_cell_value = "-"
            if run_values:
                run_cell_value = "%.4f" % min(run_values)

            if failed:
                """
                <td bgcolor="#FF0000">%s</td""" % run_cell_value
            else:
                """
                <td>%s</td""" % run_cell_value

            if prev_values and run_values:
                prev_value = min(prev_values)
                pct = safediv(min(run_values), prev_value,
                              '<center><font size=-2>nan</font></center>')
                Util.PctCell(pct, delta=True).render()
            else:
                """<td>-</td>"""


        """
        <h3>Parameter Sets</h3>
        <table border=1>
          <tr>
            <th rowspan=2>Name</th>
            <th colspan=%d>Parameters</th>
          </tr><tr>""" % len(ts_summary.parameter_sets)
        for key in ts_summary.parameter_keys:
            """
            <th>%s</th>""" % key
        """
          </tr>"""
        for (i,pset) in enumerate(ts_summary.parameter_sets):
            """
          <tr>
            <td>P%s</td>""" % (i,)
            pmap = dict(pset)
            for key in ts_summary.parameter_keys:
                item = pmap.get(key)
                if item is None:
                    item = "-"
                """
            <td>%s</td>""" % item
            """
          </tr>"""
        """
        </table>"""

        """
        <h3>Tests</h3>"""

        """
        <form method="GET" action="graph">
        <table border=1>
          <tr>
            <th></th><th>Name</th>"""
        for i in range(len(ts_summary.parameter_sets)):
            """
            <th><input type="checkbox" name="pset.%d">P%d</th>
            <th>%%</th>""" % (i, i)
        """
          </tr>"""
        for name in ts_summary.test_names:
            """
          <tr>
            <td><input type="checkbox" name="test.%s"></td>
            <td>%s</td>""" % (name, name)
            for pset in ts_summary.parameter_sets:
                test = ts_summary.test_map.get((name,pset))
                if test is None:
                    """
                <td></td><td></td>"""
                    continue

                get_cell_value(test, name, pset)
            """
          </tr>"""
        """
        </table>
        <input type="submit" value="Graph">
        </form>"""

class TagRootDirectory(NTStyleBrowser.RecentMachineDirectory):
    _q_exports = [""]

    def __init__(self, root, tag):
        NTStyleBrowser.RecentMachineDirectory.__init__(self, root)
        self.tag = tag
        self.root_path = '../..'
        self.components = ((self.tag, '%s/%s' % ('simple',self.tag)),)

    def getTags(self):
        return (self.tag,)

    def getTestRunUI(self, component):
        return SimpleRunUI(self.root, self.tag, component)

class RootDirectory(Directory):
    def __init__(self, root):
        Directory.__init__(self)
        self.root = root

    def _q_lookup(self, component):
        return TagRootDirectory(self.root, component)
